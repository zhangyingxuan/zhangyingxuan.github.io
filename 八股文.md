## JavaScript 部分

### 1. 数据类型及存储差别

- **基本类型（值类型）：** `Number`, `String`, `Boolean`, `Undefined`, `Null`, `Symbol`, `BigInt`。
- **引用类型（对象类型）：** `Object`, `Array`, `Function`, `Date`, `RegExp` 等。
- **存储差别：**
- **基本类型**存储在**栈（Stack）**中，占据空间小、大小固定，由系统自动分配和释放。
- **引用类型**存储在**堆（Heap）中，占据空间大、大小不固定。栈中仅存储指向堆内存地址的指针**。

### 2. JS 数据结构

除了基础的 `Array` 和 `Object`，现代 JS 还包括：

- **Map / WeakMap：** 键值对集合。`Map` 键可以是任意类型；`WeakMap` 键必须是对象，且是弱引用（利于垃圾回收，常用于存储 DOM 节点元数据）。
- **Set / WeakSet：** 无重复值的集合。常用于数组去重。
- **Stack / Queue：** 虽然没有原生类，但常用 `Array` 的 `push/pop`（栈）和 `push/shift`（队列）模拟。

### 3. DOM 常用操作

- **创建：** `createElement`, `createDocumentFragment`（性能优化利器）。
- **查询：** `querySelector`, `getElementById`。
- **更改：** `appendChild`, `removeChild`, `replaceChild`, `insertBefore`。
- **属性：** `setAttribute`, `getAttribute`, `classList`。

### 4. 对 BOM 的理解

**BOM (Browser Object Model)** 是浏览器对象模型，核心是 `window` 对象。

- **常用对象：**
- `location`: URL 信息（`href`, `search`, `hash`）。
- `history`: 历史记录。history.back()/forward()/go(n)、history.pushState(state, title, url)、history.replaceState(state, title, url)；**hashchange**
- `navigator`: 浏览器信息（UA 代理、在线状态）。
- `screen`: 屏幕分辨率信息。

### 5. == 与 ===

- **== (等值)：** 会进行隐式类型转换再比较。
- **=== (全等)：** 不转换，要求类型和值完全一致。
- **使用建议：** 绝大多数情况用 `===`。唯一推荐用 `==` 的场景是判断 `null` 或 `undefined`：`if (obj == null)` 等同于 `if (obj === null || obj === undefined)`。

### 6. typeof 与 instanceof

- **typeof：** 返回字符串。适于判断基本类型，但判断 `null` 和 `Array` 都会返回 `"object"`（JS 历史遗留 Bug）。
- **instanceof：** 检查构造函数的 `prototype` 是否在原型链上。适于判断对象具体类型（如 `arr instanceof Array`）。

### 7. 原型与原型链

- **原型：** 每个函数都有 `prototype` 属性，每个对象都有 `__proto__` 属性指向其构造函数的原型。
- **原型链：** 当访问对象属性时，若自身没有，则顺着 `__proto__` 向上找，直到 `Object.prototype.__proto__` 为 `null`。
- **特点：** 实现属性继承，节省内存。

### 8. 作用域链

- **定义：** 函数在定义时就决定了其内部可见的变量范围。
- **查找机制：** 当前作用域 -> 外部作用域 -> ... -> 全局作用域。这种链式查找过程即为作用域链。

### 9. this 对象的理解

`this` 在执行时绑定，而非定义时。

- **默认绑定：** 全局环境下指向 `window`。
- **隐式绑定：** 谁调用指向谁（如 `obj.func()`）。
- **显式绑定：** `call`, `apply`, `bind`。
- **new 绑定：** 指向新生成的实例。
- **箭头函数：** 没有自己的 `this`，继承自外层执行环境。

### 10. new 操作符干了什么？

1. 创建一个空对象。
2. 将该对象的 `__proto__` 指向构造函数的 `prototype`。
3. 将构造函数的 `this` 绑定到该对象并执行。
4. 若构造函数返回对象则返回该对象，否则返回新创建的对象。

### 11. call, apply, bind 区别与实现

- **区别：** `call`/`apply` 立即执行，前者传参数列表，后者传数组；`bind` 返回一个新函数。
- **bind 简易实现：**

```javascript
Function.prototype.myBind = function (context, ...args) {
  const fn = this;
  return function (...newArgs) {
    return fn.apply(context, [...args, ...newArgs]);
  };
};
```

### 12. 执行上下文与执行栈

- **执行上下文：** 代码执行的环境（全局、函数、eval）。包含变量对象、作用域链、this 指向。
- **执行栈：** 后进先出（LIFO）的结构。脚本开始执行先入栈全局上下文，函数调用时入栈函数上下文，执行完出栈。

### 13. JS 事件模型

1. **捕获阶段：** 从 window 向目标节点传播。
2. **目标阶段：** 到达目标节点。
3. **冒泡阶段：** 从目标节点向 window 传播（常用）。

### 14. 事件代理（委托）

- **原理：** 利用事件冒泡，将子元素的监听器绑定到父元素上。
- **应用：** 列表项过多时，减少内存占用，且能动态处理新增子元素。

### 15. 闭包的理解

- **定义：** 一个能访问外部函数作用域中变量的函数。
- **场景：** 数据私有化（创建私有变量）、模块化、柯里化。
- **注意：** 过多闭包会导致变量无法被回收，引起内存泄漏。

### 16. 类型转换机制

- **强制转换：** `Number()`, `String()`, `Boolean()`。
- **隐式转换：** \* `+` 运算：若有字符串则转字符串拼接。
- `-/*` 运算：转数字。
- `if` 判断：转布尔值。

### 17. 深拷贝 vs 浅拷贝

- **浅拷贝：** 只拷贝一层。修改引用类型的属性会影响原对象（`Object.assign`, `...` 扩展符）。
- **深拷贝：** 完全复制。常用 `JSON.parse(JSON.stringify())`（有局限性：无法处理函数、正则等）或递归实现。

### 18. 函数缓存（Memoization）

- **实现：** 利用闭包和对象（Map）存储输入与输出。
- **场景：** 密集型计算（如递归斐波那契、复杂的图表数据预处理）。

### 19. 常用方法

- **字符串：** `slice`, `substring`, `replace`, `includes`, `split`, `trim`。
- **数组：** \* 改变原数组：`push`, `pop`, `shift`, `unshift`, `splice`, `reverse`, `sort`。
- 不改原数组：`map`, `filter`, `reduce`, `forEach`, `slice`, `concat`, `find`。

### 20. 事件循环（Event Loop）

这是 JS 异步的核心。

1. 执行**同步代码**（宏任务）。
2. 执行完后检查并清空**微任务（Microtask）队列**（如 `Promise.then`, `MutationObserver`）。
3. 必要时渲染 UI。
4. 执行下一个**宏任务（Macrotask）**（如 `setTimeout`, `setInterval`, `I/O`）。

---

## CSS

### 1. 盒子模型（Box Model）

- **构成：** `content`（内容）、`padding`（内边距）、`border`（边框）、`margin`（外边距）。
- **标准盒模型 (`content-box`)：** `width` = 内容宽度。盒子总宽 = `width + padding + border`。
- **IE 盒模型 (`border-box`)：** `width` = 内容 + padding + border。
- **架构建议：** 现代开发通常在全局设置 `box-sizing: border-box`，因为这样更符合直觉，设定多宽，盒子就占多宽。

### 2. BFC（块级格式化上下文）

- **理解：** BFC 是页面上的一个**独立渲染区域**，内部元素的布局不会影响到外部。
- **触发条件：** `overflow` 不为 `visible`、`float` 不为 `none`、`display: flow-root`（现代方案）、`position: absolute/fixed`。
- **解决问题：** 清除浮动、防止外边距重叠（Margin Collapse）、防止元素被浮动元素覆盖。

### 3. 响应式设计（Responsive Design）

- **原理：** “一套代码，多端适配”。三大核心**流式布局、响应式图片、媒体查询（Media Queries）**。
- **做法：**

1. 设置 `viewport` 元标签。
2. 流式布局（百分比、vw/vh、rem）。
3. 响应式图片（`max-width: 100%`）。
4. 媒体查询断点切换布局。

### 4. 元素水平垂直居中

- **已知宽高：** `absolute + 负 margin` 或 `absolute + calc`。
- **不定宽高（现代方案）：**
- **Flex：** `display: flex; justify-content: center; align-items: center;`
- **Grid：** `display: grid; place-items: center;`
- **Transform：** `absolute + top: 50%; left: 50%; transform: translate(-50%, -50%);`

### 5. 布局方案

- **两栏布局（右侧自适应）：** \* `float: left` (左) + `margin-left` (右)。
- `Flex`: `flex: 1` 给右侧。

- **三栏布局（中间自适应）：** \* **圣杯布局/双飞翼布局：** 利用 `float` 和 `负 margin`（传统）。
- **Flex：** `order` 属性调整显示顺序。
- **Grid：** `grid-template-columns: auto 1fr auto;`

### 6. 选择器优先级与继承

- **优先级：** `!important > 内联 > ID > 类/伪类/属性 > 标签/伪元素 > 通配符`。
- **可继承：** 主要是文本相关属性（`font-size`, `color`, `line-height`, `text-align`）。`border`, `margin`, `padding` **不可**继承。

### 7. 隐藏元素的方式

- **`display: none`：** 不占位，触发回流/重绘，子元素也消失。
- **`visibility: hidden`：** 占位，触发重绘，子元素可通过设置 `visible` 显示。
- **`opacity: 0`：** 占位，可响应点击事件（由于透明度），性能好。

### 8. 文本溢出省略

- **单行：** `overflow: hidden; text-overflow: ellipsis; white-space: nowrap;`
- **多行：** 使用 `-webkit-line-clamp: 2; display: -webkit-box; -webkit-box-orient: vertical; overflow: hidden;`

### 9. 画一个三角形

- **原理：** 盒子的 `width/height` 设为 0，利用四条**边框（border）**交界处的斜线。
- **做法：** 三条边设为 `transparent`，剩下一条边设颜色。

### 10. 视差滚动（Parallax Scrolling）

- **CSS 方案：** `background-attachment: fixed`（简单但有性能抖动）。
- **高级方案：** `perspective` 结合 `transform-style: preserve-3d`，通过设置不同的 `translateZ` 实现滚动时的速度差。

### 11. CSS3 新特性

- **新选择器：** `:not()`, `:nth-child()`, `:last-child`。
- **视觉：** `border-radius`, `box-shadow`, `gradient`（渐变）。
- **转换：** `transform`（旋转、缩放、平移）。
- **其他：** `flex`, `grid`, `mask`, `filter`（滤镜）。

### 12. CSS3 动画

- **Transition（过渡）：** 状态改变时触发。
- **Animation（关键帧动画）：** 通过 `@keyframes` 定义复杂循环动画。
- 相比 JS 动画，CSS 动画通常能触发 GPU 加速（复合层渲染），更流畅。

### 13. Grid 网格布局

- **二维布局系统**，同时处理行和列。
- **核心：** `grid-template-areas`, `fr` 单位, `gap` 间距。适用于复杂、规则的页面大框架设计。

### 14. Flexbox 弹性盒

- **一维布局系统**（行或列）。
- **场景：** 导航栏、组件对齐、列表分布。
- **关键属性：** `flex-grow`, `flex-shrink`, `flex-basis`（简称 `flex` 简写）。

### 15. 像素相关概念

- **设备像素 (Physical Pixel)：** 屏幕硬件的物理点。
- **CSS 像素 (Logical Pixel)：** 代码中的 `px`，逻辑单位。
- **dpr (设备像素比)：** 。Retina 屏通常为 2 或 3。
- **ppi：** 每英寸像素密度。

### 16. 单位区别

- **px：** 绝对长度单位。
- **em：** 相对父元素的 `font-size`。
- **rem：** 相对**根元素 (html)** 的 `font-size`（适配首选）。
- **vh/vw：** 相对视口高度/宽度的 1%。

### 17. Chrome 小于 12px 文字

- **方式 1：** `transform: scale(0.8)`。注意：这会缩小整个容器。
- **方式 2：** 使用 `SVG` 渲染文字。
- **注意：** Chrome 12px 限制是为了易读性，非必要不建议突破。

### 18. 回流（Reflow）与重绘（Repaint）

- **回流：** 布局或几何属性（宽高、位置）改变，浏览器需重新计算页面。**代价极高**。
- **重绘：** 外观属性（颜色、背景色）改变，不影响布局。
- **场景：** 窗口缩放、增加 DOM 节点、修改字体。
- **优化：** 使用 `transform` 代替 `top/left`，利用 `DocumentFragment` 批量操作 DOM。

### 19. CSS 预编译语言（Sass/Less/Stylus）

- **理解：** 赋予 CSS 编程能力（变量、嵌套、混入 Mixin、继承）。
- **区别：** Sass（功能最强，基于 Ruby 后转向 Dart），Less（JavaScript 友好，语法简单）。
- **现代趋势：** 随着原生 CSS 变量（`--var`）和嵌套规范的普及，预编译的需求在逐渐减弱。

### 20. CSS 性能优化方法

- **减少选择器嵌套：** 层级越深，解析越慢。
- **避免使用 `expression`：** 已被淘汰，极度耗能。
- **开启 GPU 加速：** 对动画使用 `will-change` 或 `transform: translateZ(0)`。
- **文件压缩与合并：** 减少 HTTP 请求。
- **按需加载：** 提取关键 CSS（Critical CSS），非核心样式异步加载。

## ES6

---

## 1. var、let、const 的区别

这是前端面试的必考题，核心区别在于**作用域**、**提升机制**和**修改权限**。

| 特性         | var                      | let                      | const               |
| ------------ | ------------------------ | ------------------------ | ------------------- |
| **变量提升** | 允许（值为 `undefined`） | 不允许（存在暂时性死区） | 不允许              |
| **作用域**   | 函数作用域               | **块级作用域** `{}`      | **块级作用域** `{}` |
| **重复声明** | 允许                     | 不允许                   | 不允许              |
| **修改值**   | 允许                     | 允许                     | **不允许**（常量）  |

> **注意：** `const` 保证的不是变量的值不得改动，而是变量指向的那个**内存地址**所保存的数据不得改动。对于对象和数组，修改其内部属性是允许的。

---

## 2. 数组、函数、对象的扩展

### 数组扩展

- **方法：** `Array.from()` (转类数组), `find()`/`findIndex()` (查找), `includes()` (包含), `flat()` (拉平数组)。
- **扩展运算符 `...`：** 用于深拷贝数组或合并数组。

### 函数扩展

- **箭头函数：** 简洁语法，**不绑定 `this**`（继承自外层），编译时找最近的父级 this，没有 `arguments`访问的是外层函数的`arguments`。
- **默认参数：** `function log(x = 'Default') {}`。
- **剩余参数 `...args`：** 替代 `arguments` 对象。

### 对象扩展

- **属性简写：** `{ name, age }`。
- **`Object.assign()`：** 合并对象。
- **解构赋值：** `const { name } = user;`。
- **`Object.keys/values/entries`：** 用于遍历对象。

---

## 3. Promise：异步编程的终极解决方案

**理解：** Promise 是一个容器，保存着某个未来才会结束的事件（异步操作）的结果。它解决了传统的“回调地狱”问题。

- **三个状态：** `Pending` (进行中)、`Fulfilled` (已成功)、`Rejected` (已失败)。
- **特点：** 状态一旦改变就不可逆。
- **使用场景：** API 请求、定时器封装、多异步并行处理 (`Promise.all`)。

---

## 4. Module：模块化规范

**理解：** 官方提供的模块化方案，实现了代码的静态编译。

- **核心：** `export` 导出，`import` 导入。
- **使用场景：**
- 拆分复杂业务逻辑到不同文件。
- 前端组件化开发（如 Vue/React 组件导出）。
- **优点：** 减少全局变量污染，按需加载。

---

## 5. Generator：异步迭代器

**理解：** 一种可以暂停和恢复执行的函数。

- **标志：** `function*` 和 `yield` 关键字。
- **使用场景：**
- 控制复杂异步流。
- 配合 `co` 库实现自动执行。
- **现状：** 大部分场景已被 `async/await` 取代，但在处理大数据流或特定中间件（如 Redux-Saga）时依然强大。

---

## 6. Decorator：装饰器（草案阶段）

**理解：** 这是一个包装器，在不修改原代码的情况下，扩展类或类属性的功能。

- **语法：** `@decoratorName`。
- **使用场景：**
- 日志打印、权限校验。
- 在框架（如 Angular 或 NestJS）中用于定义路由、注入依赖。

---

## 7. Set 与 Map 数据结构

**Set（集合）：** 类似于数组，但**成员的值都是唯一的**。

- **场景：** 数组去重、求交集/并集。

**Map（字典）：** 类似于对象，但**“键”的范围不限于字符串**（可以是对象、函数等）。

- **场景：** 需要频繁增删键值对、或者键名包含复杂对象的映射。

---

## 8. Proxy：代理与拦截

**理解：** 在目标对象之前架设一层“拦截”，可以监听对对象的所有操作（读、写、删除等）。

- **使用场景：**
- **数据响应式：** Vue 3.0 的响应式原理核心。
- **数据校验：** 在设置属性前进行格式检查。
- **控制权限：** 隐藏私有属性。

## Vue2

针对 Vue 2 的核心考察点，这里为你梳理了一份通俗易懂且极具实战价值的回答指南：

---

### 1. Vue 生命周期的理解

生命周期是指 Vue 实例从创建、初始化、挂载、更新到销毁的完整过程。

- **创建阶段**：`beforeCreate`（数据观测还没开始）、`created`（数据有了，但 DOM 还没生成，适合发异步请求）。
- **挂载阶段**：`beforeMount`、`mounted`（DOM 挂载完毕，可以进行 DOM 操作）。
- **更新阶段**：`beforeUpdate`、`updated`（数据变了，页面也刷新了）。
- **销毁阶段**：`beforeDestroy`（实例销毁前，**必须在此清除定时器、解绑全局事件**）、`destroyed`。

---

### 2. 双向数据绑定

指的是 **数据层 (Model)** 和 **视图层 (View)** 的实时同步。

- **原理**：采用**数据劫持**配合**发布者-订阅者模式**。通过 `Object.defineProperty()` 拦截各个属性的 `getter`（依赖收集）和 `setter`（派发更新）。

---

### 3. 组件通信方式

- **父子**：`props` / `$emit`。
- **跨级**：`provide` / `inject`、`$attrs` / `$listeners`。
- **兄弟/任意**：Vuex、EventBus（`new Vue()` 作为中心）。
- **直接访问**：`$parent` / `$children`、`ref`。

---

### 4. 为什么 data 必须是函数？

Vue 组件可能被多次实例化。如果 `data` 是对象，由于 JS 的**对象是引用类型**，所有实例将共享同一个数据对象（改一个全变了）。**函数返回对象**能确保每个实例都拥有独立的数据拷贝，互不干扰。

---

### 5. 动态添加新属性会发生什么？

- **现象**：直接 `this.obj.newKey = 'xxx'`，数据变了但**页面不会更新**。
- **原因**：Vue 2 在初始化时已经完成了 `getter/setter` 绑定，后期新增的属性没有被劫持。
- **解决**：使用 `this.$set(target, key, value)`。

---

### 6. v-if 和 v-for 的优先级

- **优先级**：在 Vue 2 中，`v-for` 的优先级**高于** `v-if`。
- **后果**：如果写在一起，每次循环都会执行一次判断，极其浪费性能。
- **方案**：在外面包裹一层 `template` 走 `v-if`，或者在 `computed` 里提前过滤数据。

---

### 7. v-show vs v-if

- **v-if**：**“真正”的条件渲染**。切换时会销毁/重建组件。有更高的切换开销。
- **v-show**：**简单的 CSS 切换**。始终渲染，只是控制 `display: none`。有更高的初始渲染开销。
- **场景**：频繁切换用 `v-show`；运行条件不大可能改变用 `v-if`。

---

### 8. Key 的原理

`key` 是虚拟 DOM 的唯一标识。

- **作用**：在 Diff 算法中更准确、更快地找到旧节点。
- **理解**：如果不加 key，Vue 会使用“就地复用”策略，导致表单状态错位或性能下降。有了 key，Vue 就能感知到节点的真实移动，而不是单纯的属性替换。

---

### 9. Mixin 的理解

- **概念**：抽离组件中公共的逻辑（data, methods, 钩子等）。
- **场景**：多个页面都有搜索功能、打点统计逻辑时。
- **缺点**：变量来源不清晰，容易产生命名冲突。

---

### 10. 修饰符

- **事件**：`.stop`（阻止冒泡）、`.prevent`（阻止默认）、`.once`。
- **表单**：`.lazy`（change 时同步）、`.trim`、`.number`。

---

### 11. $nextTick 的作用

Vue 更新 DOM 是**异步**的。当你修改数据后，立即获取 DOM 元素内容还是旧的。

- **作用**：在下次 DOM 更新循环结束之后执行延迟回调。
- **场景**：修改数据后，想要立即获取新 DOM 的宽高或操作其中的插件。

---

### 12. 虚拟 DOM 与 Diff 算法

- **虚拟 DOM**：用 JS 对象模拟真实 DOM 结构，通过减少直接操作 DOM 来提升性能。
- **Diff 算法**：采用**同层比较**（不跨层）。核心是**双端交叉对比**：同时从新旧子节点列表的两端向中间遍历，尽量复用节点。

---

### 13. 组件 vs 插件

- **组件**：UI 结构的封装（Button, List），通过 `components` 引入。
- **插件**：功能的封装（VueRouter, Vuex, 统一弹窗指令）。通过 `Vue.use()` 安装，通常会往全局注入方法、指令或原型属性。

---

### 14. 跨域解决

- **开发环境**：在 `vue.config.js` 配置 `devServer.proxy` 代理。
- **生产环境**：Nginx 反向代理、后端开启 CORS。

---

### 15. 自定义指令

- **写法**：`directives: { focus: { inserted(el) { el.focus() } } }`。
- **场景**：权限控制（`v-auth`）、图片懒加载、点击外部关闭弹窗。

---

### 16. Slot 插槽

- **理解**：子组件预留占位符，父组件决定填什么。
- **类型**：默认插槽、具名插槽、**作用域插槽**（子组件把数据传回给父组件显示）。
- **场景**：通用组件（如 Modal 弹窗）的内容定制。

---

### 17. Axios 封装

- **拦截器**：请求拦截器自动带上 `token`；响应拦截器统一处理 401（跳登录）、500 报错。
- **状态管理**：根据环境切换 `baseURL`。

---

### 18. 错误处理

- **组件内**：`errorCaptured` 钩子。
- **全局**：`Vue.config.errorHandler`。
- **接口**：Axios 的 `.catch` 或拦截器统一提示。
- **全局 JS/资源 加载异常**
  `window.onerror= function(message, source, lineno, colno, error) {};`
  `window.addEventListener('error', (event) => {})`
- **未捕获的 Promise 异常**：Axios 的 `.catch` 或拦截器统一提示。
  `window.addEventListener('unhandledrejection', (event) => {})`

---

## Vue3

Vue 3.0 是对 Vue 2.x 的一次重大重构，不仅在底层架构上做了性能飞跃，更在开发范式上引入了 Composition API，解决了复杂业务逻辑难以维护的痛点。

---

## 1. Composition API vs Options API

这是 Vue 3 最直观的变化。

- **Options API (Vue 2)**：按**配置项**组织代码（`data`、`methods`、`computed`）。
- _缺点_：逻辑被强行拆分到不同配置项中。当组件变得庞大时，同一个功能的代码会散落在各处，反复“上下反复横跳”非常痛苦。

- **Composition API (Vue 3)**：按**逻辑功能**组织代码。
- _优点_：使用 `setup()` 函数，可以将相同功能的数据、方法、生命周期封装在一起，甚至提取到外部作为 `hook` 函数，极大提高了代码的可复用性和可维护性。

---

## 2. Vue 3.0 的设计目标与优化

核心目标：**更小、更快、更易于扩展、更友好的类型推导。**

- **源码体积优化**：引入 Tree-shaking，让不用的功能（如 `keep-alive`）不打包进最终文件。
- **数据劫持优化**：由 `Proxy` 替代 `Object.defineProperty`。
- **编译优化**：引入静态提升（Static Hoisting）、补丁标记（Patch Flag）。
- **更好的 TS 支持**：源码采用 TypeScript 重写。

---

## 3. 如何设计一个 Modal 组件？

在 Vue 3 中设计 Modal，重点在于**逻辑抽离**与**传送门技术**。

1. **Teleport (传送门)**：Modal 的 DOM 结构通常需要挂载在 `body` 下，避免受父级 `z-index` 或 `overflow: hidden` 的影响。

```html
<teleport to="body">
  <div v-if="visible" class="modal">...</div>
</teleport>
```

2. **组合式逻辑抽离**：将 Modal 的显示/隐藏逻辑封装成一个 `useModal` hook，方便多处复用。
3. **单向数据流**：通过 `modelValue` 实现双向绑定（Vue 3 的 `v-model`），并通过 `emits` 触发关闭。

---

## 4. 性能提升体现在哪几方面？

Vue 3 的快是全方位的：

- 响应式系统 (Proxy vs Object.defineProperty)：内存占用： 减少了约 50%、初始化速度： 提升了约 2 倍（跳过了繁重的递归观测，使用时代理）
- **Diff 算法升级**：Vue 2 是全量对比，Vue 3 增加了 **Patch Flag (补丁标记)**。在编译阶段标记出哪些是动态绑定（如 `:class`），更新时只对比这些有标记的节点。**静态提升 (Hoisting)**：模板中不动的静态节点会被提取到 `render` 函数外，只需创建一次，下次更新直接复用。**更新性能**： 在只有少量动态绑定的页面中，更新速度可提升 2 - 5 倍。
- **侦听器缓存 (Cache Handlers)**：内联函数（如 `@click`）会被缓存，避免不必要的子组件重新渲染。
- **打包体积 (Tree-shaking)**，基准体积： 压缩后仅为 10kb - 16kb 左右。体积比 Vue 2 缩小了约 41%

---

## 5. 为什么用 Proxy 替代 defineProperty？

这是 Vue 3 解决“玄学 Bug”的关键：

1. **检测不到属性增删**：Vue 2 无法监听对象属性的添加和删除，必须用 `$set`。`Proxy` 原生支持。
2. **数组监听痛点**：Vue 2 需要重写数组方法（push/pop 等）。`Proxy` 可以完美监听数组下标变化。
3. **性能优势**：`defineProperty` 需要在初始化时递归遍历对象所有属性；`Proxy` 是**懒处理**，只有访问到深层对象时才进行劫持，初始渲染更快。

---

## 6. Tree-shaking 特性

**Tree-shaking** 翻译过来是“摇树”，即在构建时剔除那些未被引用的“死代码”。

- **Vue 2**：很多 API（如 `$nextTick`）是挂载在全局 Vue 对象上的，即便你没用，打包工具也很难删掉它们。
- **Vue 3**：将 API 模块化。你必须通过 `import { nextTick, ref } from 'vue'` 来引入。
- **举例**：如果你在项目中没有使用 `Transition` 或 `v-model`，构建工具（Vite/Webpack）在打包时就不会包含这些特性的代码，最终的 `vendor.js` 会小很多。

---

**修饰符：**要理解 .capture，必须先理解 DOM 事件流的两个阶段：
捕获阶段 (Capture Phase)：事件从 window 向下传播，经过父元素，直到到达目标元素。
冒泡阶段 (Bubbling Phase)：事件从目标元素向上回传，经过父元素，直到 window。

## React

---

### 1. 对 React 的理解与特性

- **理解：** React 是一个用于构建用户界面的 **JavaScript 库**（而非框架）。它通过**声明式编码**、**组件化**和**通用性**（React Native/SSR）改变了前端开发方式。
- **特性：** \* **虚拟 DOM：** 减少真实 DOM 操作。
- **单向数据流：** 数据从父传到子，逻辑清晰可控。
- **JSX：** JS 的语法扩展，让 UI 逻辑与标签结构深度融合。
- **Fiber：** 使渲染过程可中断，保障大任务下的交互流畅度。

---

### 2. state vs props

- **props（外部传入）：** 组件的配置项。它是**只读**的，由父组件传递给子组件。
- **state（内部私有）：** 组件的状态机。它是**可变**的，由组件自身维护。更新 `state` 会触发重新渲染。

---

### 3. super() vs super(props)

- **在构造函数中：**
- `super()`：调用父类 `React.Component` 的构造函数。
- `super(props)`：除了调用父类，还会将 `props` 绑定到 `this` 上。如果在 `constructor` 中需要使用 `this.props`，必须传参数；否则 React 会在构造函数结束后自动帮你赋值。

---

### 4. 类组件 (Class) vs 函数组件 (Function)

- **类组件：** 依赖 `this`，有完整的生命周期钩子，较重。
- **函数组件：** 早期是无状态组件。引入 **Hooks** 后，具备了状态管理和副作用处理能力。
- **区别：** 函数组件捕获了渲染时的值（Capture Value），逻辑复用（Custom Hooks）更优雅，是目前 React 的主流推荐。

---

### 5. 受控组件 vs 非受控组件

- **受控组件：** 表单数据由 React 的 `state` 管理。每当输入改变，`state` 更新，视图随之改变。
- **非受控组件：** 表单数据由 DOM 自身处理。通过 `ref` 直接从 DOM 节点获取值。
- **应用场景：** 大多数情况用受控组件；涉及文件上传或对第三方 DOM 插件封装时用非受控组件。

---

### 6. React 事件机制

- **合成事件 (SyntheticEvent)：** React 并不是将事件直接绑定到真实 DOM 节点上，而是通过**事件委托**的方式挂载到根节点（React 17+ 为渲染根节点）。
- **目的：** 跨浏览器兼容、垃圾回收优化、以及跨端开发的统一模型。

---

### 7. 事件绑定方式

- `render` 中使用 `bind`：每次渲染都创建新函数，性能较差。
- `render` 中使用箭头函数：同上，会导致子组件不必要的重新渲染。
- **构造函数中使用 `bind`：** 只绑定一次。
- **类成员变量（箭头函数）：** 最推荐。语法简洁且能正确绑定 `this`。

---

### 8. 构建组件的方式

- `React.createClass`（已废弃）。
- `ES6 Class` 组件。
- **函数组件 (FC)**：目前的主流。

---

### 9. 引入 CSS 的方式

- **Inline CSS：** 动态性强，但无法使用伪类和媒体查询。
- **CSS Modules：** 局部作用域，解决类名冲突，是中大型项目首选。
- **CSS-in-JS (Styled-components)：** 逻辑与样式深度绑定，适合组件库开发。
- **Sass/Less：** 传统的预处理器。

---

### 10. 生命周期阶段 (Class Component)

- **挂载 (Mounting)：** `constructor` -> `getDerivedStateFromProps` -> `render` -> `componentDidMount`。
- **更新 (Updating)：** `getDerivedStateFromProps` -> `shouldComponentUpdate` -> `render` -> `getSnapshotBeforeUpdate` -> `componentDidUpdate`。
- **卸载 (Unmounting)：** `componentWillUnmount`。

---

### 11. 组件通信

- **父传子：** Props。
- **子传父：** 父组件传递回调函数。
- **跨级：** `Context API`。
- **全局：** `Redux` / `Zustand` / `Recoil`。

---

### 12. 高阶组件 (HOC)

- **理解：** 一个函数，接收一个组件并返回一个新组件。它是 React 中**复用组件逻辑**的高级技术。
- **应用场景：** 权限控制、日志打点、数据注入（如 `withRouter`）。

---

### 13. 过渡动画实现

- 使用 `react-transition-group`。
- 使用 `framer-motion`（目前社区最火，功能强大）。
- 原生 CSS 结合生命周期切换类名。

---

### 14. 错误捕获

- **Error Boundaries (错误边界)：** 这是一个类组件，通过 `static getDerivedStateFromError` 和 `componentDidCatch` 捕获子组件树的渲染错误。
- **注意：** 无法捕获异步代码、事件处理或服务器端渲染的错误。

---

### 15. Refs 的理解

- **理解：** 允许我们直接访问 DOM 节点或组件实例。
- **应用场景：** 管理焦点、触发动画、集成第三方 DOM 库。

---

### 16. setState 执行机制

- **异步 vs 同步：** 在 React 18 之前，在 `setTimeout` 或原生事件中是同步的。**React 18 开启了自动批处理 (Automatic Batching)**，现在几乎所有地方都是异步（批处理）的。
- **合并更新：** 多次调用 `setState` 会合并为一次重新渲染以提升性能。

---

### 17. Render 原理与触发

- **原理：** `render` 返回 JSX 结构，React 将其转换为虚拟 DOM 树，然后通过 **Diff 算法** 计算差异并应用到真实 DOM。
- **触发时机：** `state` 改变、`props` 改变、父组件重新渲染（除非使用 `React.memo`）、`forceUpdate()`。

---

### 18. Real DOM vs Virtual DOM

- **Real DOM：** 更新开销大，每次改动可能触发整个树的重排。
- **Virtual DOM：** 以 JS 对象形式描述 UI。
- **优点：** 跨平台、减少 DOM 操作频率。
- **缺点：** 初始渲染需要额外内存和计算。

---

### 19. JSX 转真实 DOM 的过程

1. **解析：** Babel 将 JSX 转换为 `React.createElement` 调用。
2. **创建：** 转换为虚拟 DOM 对象。
3. **渲染 (Commit)：** `ReactDOM.render`（或 React 18 的 `createRoot`）通过 Diff 比较，将变更应用到真实 DOM。

---

### 20. Fiber 架构

- **背景：** 以前的 Stack Reconciler 是同步递归的，当组件树很大时会阻塞主线程。
- **理解：** Fiber 将渲染任务拆分为多个**微小的任务单元**。
- **解决问题：** 引入**时间切片 (Time Slicing)**。它允许渲染过程被中断（让位给高优先级的交互事件，如点击），然后再恢复。

---

## Node.JS

说说你对 Node.js 的理解?优缺点?应用场景?
说说对 Node 中的 fs 模块的理解?有哪些常用方法
说说对 Node 中的 Buffer 的理解?应用场景?
说说对 Node 中的 Stream 的理解?应用场景?
说说对 Node 中的 process 的理解?有哪些常用方法?
说说 Node 中的 EventEmitter?如何实现一个 EventEmitter?
说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?
说说 Node 有哪些全局对象?
说说对中间件概念的理解,如何封装 node 中间件?
说说对 Nodejs 中的事件循环机制理解?
Node 性能如何进行监控以及优化?
如何实现文件上传?说说你的思路
如何实现 jwt 鉴权机制?说说你的思路
如果让你来设计一个分页功能,你会怎么设计?前后端如何交互?

## 小程序

说说你对微信小程序的理解?优缺点?
说说微信小程序的生命周期函数有哪些?
说说微信小程序的登录流程?
说说微信小程序中路由跳转的方式有哪些?区别?
说说微信小程序的发布流程?
说说微信小程序的支付流程?
说说微信小程序的实现原理?
说说提高微信小程序的应用速度的手段有哪些?

## HTTP

对于前端架构师而言，网络协议是决定应用性能、安全性与实时性的底层命脉。特别是在赛力斯这种涉及 **IoT 设备接入（充电桩）**与 **实时监控（大屏）**的场景下，对协议的深度掌握尤为重要。

---

### 1. 如何理解 OSI 七层模型？

OSI 是一个逻辑上的标准框架。从下到上依次为：

1. **物理层**：比特流传输。
2. **数据链路层**：帧传输，MAC 地址。
3. **网络层**：IP 协议，路径选择（路由器）。
4. **传输层**：TCP/UDP，提供端到端通信。
5. **会话层**：建立、管理会话。
6. **表示层**：数据格式化、加密解密（如 ASCII、SSL/TLS）。
7. **应用层**：HTTP、FTP、DNS。

---

### 2. 如何理解 TCP/IP 协议？

TCP/IP 是互联网的实际工业标准，将 OSI 简化为四层：

- **网络接口层**（物理+链路）
- **网络层**（IP）
- **传输层**（TCP/UDP）
- **应用层**（HTTP/FTP/DNS）

---

### 3. UDP 和 TCP 的区别及应用场景

- **TCP (面向连接)**：可靠。通过确认号、重传机制保证数据无差错。适用于：**网页浏览 (HTTP)、文件传输 (FTP)、邮件 (SMTP)**。
- **UDP (面向无连接)**：不可靠但速度快，头部开销小。适用于：**实时音视频、直播、IoT 设备状态高频上报（如充电桩心跳包）**。

---

### 4. GET 和 POST 的区别？

- **语义**：GET 用于获取资源，POST 用于提交/更改资源。
- **参数**：GET 参数在 URL 中；POST 参数在 Request Body 中。
- **缓存**：GET 可被浏览器主动缓存，POST 默认不会。
- **安全性**：都不安全（明文），但 POST 参数不在地址栏，略优于 GET。
- **数据长度**：GET 受 URL 长度限制（浏览器限制），POST 理论无限制。

---

### 5. TCP 的三次握手与四次挥手

- **三次握手**：

1. 客户端：我有能力发，你能收到吗？ (SYN)
2. 服务端：收到了，我有能力发，你能收到吗？ (SYN+ACK)
3. 客户端：收到了，开始传输。 (ACK)

- **原因**：防止已失效的连接请求突然传到服务端产生错误。

- **四次挥手**：
- **原因**：TCP 是全双工的。客户端发完 FIN 表示不再发数据，但服务端可能还有数据没发完，需要先回复 ACK，等数据发完后再发 FIN。

---

### 6. HTTP 常见请求头

- **Accept**：客户端能处理的内容类型。
- **Cache-Control**：缓存控制（如 `no-cache`, `max-age`）。
- **Cookie**：携带的身份标识。
- **User-Agent**：浏览器/设备信息。
- **Authorization**：身份验证（如 JWT）。

---

### 7. HTTP 常见状态码

- **200**：请求成功。
- **301/302**：永久/临时重定向（301 有利于 SEO）。
- **304**：命中协商缓存（资源未修改）。
- **401**：禁止访问（未登录，权限不足）。
- **403**：禁止访问（已登录，权限不足）。
- **404**：资源不存在。
- **500**：服务器内部错误。
- **503**：服务器超载或维护。

---

### 8. HTTP vs HTTPS

- **HTTP**：明文传输，不安全，端口 80。
- **HTTPS**：HTTP + SSL/TLS。加密传输、身份认证、完整性保护，端口 443。

---

### 9. HTTP 1.0 / 1.1 / 2.0 的区别

- **1.0**：短连接，每个请求创建一个 TCP 连接。
- **1.1**：**长连接 (Keep-Alive)**、管道化、强制缓存/协商缓存。
- **2.0**：**多路复用**（一个连接并发多个请求）、头部压缩 (HPACK)、二进制分帧、服务器推送。

---

### 10. HTTPS 如何保证安全？

混合加密机制：TLS/SSL（Secure Sockets Layer）（目前已因安全漏洞被废弃，目前使用 TLS（Transport Layer Security））

1. **非对称加密**：建立连接阶段，交换对称加密的密钥。
2. **对称加密**：数据传输阶段，使用交换好的密钥加密内容。
3. **CA 证书**：防止中间人劫持，验证服务器身份。

---

### 11. 什么是 CDN？原理是什么？

**内容分发网络**。通过将静态资源（JS/CSS/图片）分发到离用户最近的节点。

- **原理**：

1. 用户请求 URL。
2. DNS 解析到 CNAME，指向 CDN 的调度服务器。
3. 调度服务器根据用户 IP 分配最优边缘节点。
4. 节点有缓存直接返回，无缓存则回源站抓取并缓存。

---

### 12. DNS 完整的查询过程

1. **浏览器缓存** -> **操作系统缓存** -> **Hosts 文件**。
2. **LDNS (本地 DNS 服务器)**：通常是你的运营商。
3. **根域名服务器** (`.`) -> **顶级域名服务器** (`.com`) -> **权限域名服务器** (`seres.com`)。
4. 返回 IP 给 LDNS，LDNS 缓存并返回给浏览器。

---

### 13. 对 WebSocket 的理解

WebSocket 是 HTML5 引入的 **持久化全双工通信协议**。

- **特点**：一次握手（借用 HTTP），建立后双方可随时推送数据。
- **场景**：充电大屏实时告警、充电桩充电进度实时显示、聊天室。

---

### 14. 输入 URL 敲下回车后发生了什么？

1. **解析 URL**：判断是搜索还是访问。
2. **DNS 解析**：获取 IP。
3. **建立 TCP 连接**：三次握手。
4. **发送 HTTP 请求**。
5. **服务器处理并返回响应**。
6. **浏览器解析渲染**：

- 构建 DOM 树。
- 构建 CSSOM 树。
- 合并为 Render Tree。
- **布局 (Layout)** 与 **绘制 (Paint)**。合成 **Composite**

7. **连接关闭**：四次挥手。

---

## TypeScript

说说你对 TypeScript 的理解?与 JavaScript 的区别?
说说 typescript 的数据类型有哪些?
说说你对 TypeScript 中高级类型的理解?有哪些?
说说你对 TypeScript 中接口的理解?应用场景?
说说你对 TypeScript 中类的理解?应用场景?
说说你对 TypeScript 中枚举类型的理解?应用场景?
说说你对 TypeScript 中函数的理解?与 JavaScript 函数的区别?
说说你对 TypeScript 中泛型的理解?应用场景?
说说你对 TypeScript 装饰器的理解?应用场景?
说说对 TypeScript 中命名空间与模块的理解?区别?
说说如何在 React 项目中应用 TypeScript?
说说如何在 Vue 项目中应用 TypeScript?

## Webpack

说说你对 webpack 的理解?解决了什么问题?
说说 webpack 的热更新是如何做到的?原理是什么?
说说 webpack 的构建流程?
说说 webpack proxy 工作原理?为什么能解决跨域?
说说 webpack 中常见的 Loader?解决了什么问题?
说说 webpack 中常见的 Plugin?解决了什么问题?
说说 Loader 和 Plugin 的区别?编写 Loader，Plugin 的思路?
如何提高 webpack 的构建速度?
说说如何借助 webpack 来优化前端性能?
与 webpack 类似的工具还有哪些?区别?

## Git

说说你对版本管理的理解?常用的版本管理工具有哪些?
说你对 Git 的理解?
说说 Git 常用的命令有哪些?
说说 Git 中 HEAD、工作树和索引之间的区别?
说说 git 发生冲突的场景?如何解决?
说说 Git 中 fork,clone,branch 这三个概念,有什么区别?
说说对 git pull 和 git fetch 的理解?有什么区别?
说说你对 git rebase 和 git merge 的理解?区别?
说说你对 git reset 和 git revert 的理解?区别?
说说你对 git stash 的理解?应用场景?

## 算法与数据结构

说说你对数据结构的理解?有哪些?区别?
说说你对算法的理解?应用场景?
说说你对算法中时间复杂度,空间复杂度的理解?如何计算?
说说你对集合的理解?常见的操作有哪些?
说说你对树的理解?相关的操作有哪些?
说说你对栈、队列的理解?应用场景?
说说你对链表的理解?常见的操作有哪些?
说说你对堆的理解?如何实现?应用场景?
说说你对图的理解?相关操作有哪些?
说说常见的排序算法有哪些?区别?
说说你对冒泡排序的理解?如何实现?应用场景?
说说你对二分查找的理解?如何实现?应用场景?
说说你对快速排序的理解?如何实现?应用场景?
说说你对选择排序的理解?如何实现?应用场景?
说说你对插入排序的理解?如何实现?应用场景?
说说你对分而治之、动态规划的理解?区别?
说说你对归并排序的理解?如何实现?应用场景?
说说你对贪心算法、回溯算法的理解?应用场景?
