---
title: 2025-05-04-【工程化】主流模块系统对比分析
description: 深入解析CommonJS、ES Modules、AMD、UMD、IIFE等主流JavaScript模块系统的技术特点、适用场景和现代开发中的最佳实践选择
categories:
  - 工程化
tags:
  - JavaScript
  - 模块化
  - CommonJS
  - ES Modules
  - AMD
  - UMD
  - IIFE
---

## 引言

随着前端项目规模的不断扩大，模块化开发已成为现代 JavaScript 开发的基石。不同的模块系统各有优劣，理解它们的特性和适用场景对于构建高效、可维护的应用程序至关重要。本文将深入对比分析 CJS、ESM、AMD、UMD、IIFE 等主流模块系统。

# 主流模块系统对比（CJS/ESM/AMD/UMD/IIFE）

| 对比维度              | CJS（CommonJS）                                                 | ESM（ES Modules，ES6+）                                                                   | AMD（异步模块定义）                                                        | UMD（通用模块定义）                             | IIFE（立即执行函数）                                |
| --------------------- | --------------------------------------------------------------- | ----------------------------------------------------------------------------------------- | -------------------------------------------------------------------------- | ----------------------------------------------- | --------------------------------------------------- |
| **核心定位**          | Node.js 原生同步模块系统，服务端基准                            | ES 官方标准模块系统，适配浏览器+Node.js                                                   | 浏览器端异步模块系统（RequireJS 实现）                                     | 跨环境兼容模块（CJS+AMD+全局变量）              | 浏览器端无模块系统时的「伪模块」方案                |
| **语法特征**          | - 导出：`module.exports`/`exports`；<br>- 导入：`require()`     | - 导出：`export`/`export default`；<br>- 导入：`import`/`import()`                        | - 导出：`define([依赖], factory)`；<br>- 导入：`require([模块], callback)` | 无专属语法，包裹 CJS/AMD 逻辑，自动适配环境     | 无导入导出，通过闭包封装作用域，挂载到全局          |
| **加载时机**          | 运行时加载（执行到 `require` 才加载）                           | 编译时静态分析（导入导出提升到模块顶部）                                                  | 运行时异步加载（不阻塞页面）                                               | 运行时适配环境后加载                            | 脚本加载后立即执行                                  |
| **加载方式**          | 同步加载（阻塞执行）                                            | 同步加载（默认）+ 异步加载（`import()`）                                                  | 异步加载（核心设计目标）                                                   | 同步/异步取决于适配的环境（CJS 同步、AMD 异步） | 无加载逻辑，一次性执行                              |
| **依赖解析**          | 动态解析（`require` 可写在条件语句中）                          | 静态解析（导入导出不可写在条件语句中）                                                    | 动态解析（依赖数组可动态生成）                                             | 动态/静态取决于适配的环境                       | 无依赖解析，需手动管理依赖顺序                      |
| **运行环境**          | 原生支持：Node.js；<br>浏览器：需打包工具（Webpack/Rollup）转译 | 原生支持：现代浏览器（ES6+）、Node.js 14.13+；<br>旧环境：需转译/Polyfill                 | 原生支持：浏览器（RequireJS）；<br>Node.js：需适配                         | 全环境（浏览器/Node.js/无模块环境）             | 仅浏览器（无模块系统）                              |
| **模块作用域**        | 每个模块独立作用域，`this` 指向 `module.exports`                | 每个模块独立作用域，`this` 指向 `undefined`                                               | 每个模块独立作用域                                                         | 继承 CJS/AMD 作用域特性                         | 闭包隔离作用域，全局变量作为对外接口                |
| **循环依赖处理**      | 支持（返回已加载的部分模块对象，可能拿到空对象）                | 支持（编译时解析依赖关系，无空对象问题）                                                  | 支持（异步加载，按依赖顺序执行）                                           | 继承 CJS/AMD 处理逻辑                           | 不支持（依赖顺序错误会导致变量未定义）              |
| **顶层 `await` 支持** | 不支持（需包裹在 async 函数中）                                 | 原生支持（模块顶层可直接用 `await`）                                                      | 不支持（需在 factory 中异步处理）                                          | 仅适配 ESM 环境时支持                           | 不支持                                              |
| **文件扩展名**        | 无强制（Node.js 默认识别 `.js`/`.cjs`）                         | Node.js 需 `.mjs` 或 `package.json` 声明 `"type": "module"`；<br>浏览器无强制             | 无强制，通常 `.js`                                                         | 无强制，通常 `.js`                              | 无强制，通常 `.js`                                  |
| **只读导入**          | 导入的模块对象可修改（如 `require('./a').x = 1`）               | 导入的绑定是只读的（修改会报错）                                                          | 导入的模块对象可修改                                                       | 取决于适配的环境（ESM 只读，CJS/AMD 可改）      | 全局变量可修改                                      |
| **Tree Shaking 支持** | 不支持（动态加载，无法静态分析未使用代码）                      | 原生支持（静态解析，可剔除未导出/未使用代码）                                             | 不支持（动态加载）                                                         | 仅适配 ESM 环境时支持                           | 不支持（无静态分析）                                |
| **典型使用场景**      | 1. Node.js 服务端开发（非 ESM 项目）；<br>2. 旧版前端打包项目   | 1. 现代前端项目（Vue/React/Vite）；<br>2. Node.js 14+ 服务端；<br>3. 浏览器原生模块化开发 | 旧版浏览器异步加载脚本（如 RequireJS 项目）                                | 跨环境库开发（如 jQuery、Lodash 等通用库）      | 无构建工具的纯浏览器项目、第三方脚本（如广告/统计） |

# CJS vs ESM 核心差异补充对比表

| 对比维度           | CJS（CommonJS）                       | ESM（ES Modules，ES6+）                          |
| ------------------ | ------------------------------------- | ------------------------------------------------ |
| 导出本质           | 导出 `module.exports` 对象的引用      | 导出值的绑定（只读）                             |
| 导入方式           | 仅支持 `require()` 动态导入           | 支持 `import` 静态导入 + `import()` 动态导入     |
| 作用域 `this` 指向 | `module.exports`                      | `undefined`                                      |
| Node.js 启用方式   | 默认启用（`.js`/`.cjs`）              | `.mjs` 文件 或 `package.json` `"type": "module"` |
| 互操作支持         | 可 `require` ESM（需异步 `import()`） | 可 `import` CJS（视为默认导出）                  |
| 静态优化能力       | 无（动态特性无法静态分析）            | 支持 Tree Shaking、类型校验等静态优化            |

## 模块系统发展历程

### 1. IIFE (Immediately Invoked Function Expression)

**出现时间**: 早期 JavaScript
**设计目标**: 解决全局命名空间污染问题

#### 语法特点

```javascript
// IIFE基本语法
(function (global) {
  var privateVar = "private";
  function privateFunction() {
    return privateVar;
  }

  // 暴露到全局
  global.myModule = {
    publicMethod: privateFunction,
  };
})(window);

// 使用模块
myModule.publicMethod();
```

#### 优缺点

- ✅ **优点**: 简单易用，兼容性好，避免全局污染
- ❌ **缺点**: 依赖管理困难，无法按需加载，模块关系不清晰

### 2. AMD (Asynchronous Module Definition)

**出现时间**: 2009 年
**代表库**: RequireJS
**设计目标**: 浏览器端异步模块加载

#### 语法特点

```javascript
// 定义模块
define(["dependency1", "dependency2"], function (dep1, dep2) {
  return {
    method: function () {
      return dep1.someMethod() + dep2.anotherMethod();
    },
  };
});

// 使用模块
require(["myModule"], function (myModule) {
  myModule.method();
});
```

#### 优缺点

- ✅ **优点**: 支持异步加载，依赖关系清晰，适合浏览器环境
- ❌ **缺点**: 语法相对复杂，需要额外的加载器

### 3. CommonJS (CJS)

**出现时间**: 2009 年
**应用场景**: Node.js 环境
**设计目标**: 服务器端同步模块加载

#### 语法特点

```javascript
// 导出模块
const privateVar = "private";
function privateFunction() {
  return privateVar;
}

module.exports = {
  publicMethod: privateFunction,
};

// 或者使用exports
exports.publicMethod = privateFunction;

// 导入模块
const myModule = require("./myModule");
myModule.publicMethod();
```

#### 优缺点

- ✅ **优点**: 语法简单直观，Node.js 原生支持，同步加载适合服务器环境
- ❌ **缺点**: 不适合浏览器环境（同步阻塞），无法 tree shaking

### 4. UMD (Universal Module Definition)

**出现时间**: 2011 年
**设计目标**: 兼容多种模块系统的通用解决方案

#### 语法特点

```javascript
(function (root, factory) {
  if (typeof define === "function" && define.amd) {
    // AMD
    define(["dependency"], factory);
  } else if (typeof exports === "object") {
    // CommonJS
    module.exports = factory(require("dependency"));
  } else {
    // 浏览器全局变量
    root.myModule = factory(root.dependency);
  }
})(this, function (dependency) {
  return {
    method: function () {
      return dependency.someMethod();
    },
  };
});
```

#### 优缺点

- ✅ **优点**: 高度兼容，一套代码多环境运行
- ❌ **缺点**: 代码冗余，文件体积较大

### 5. ES Modules (ESM)

**出现时间**: ES6 (2015 年)
**设计目标**: JavaScript 语言级别的模块标准

#### 语法特点

```javascript
// 导出模块
const privateVar = "private";
function privateFunction() {
  return privateVar;
}

// 命名导出
export function publicMethod() {
  return privateFunction();
}

export const publicVar = "public";

// 默认导出
export default {
  publicMethod,
  publicVar,
};

// 导入模块
import { publicMethod, publicVar } from "./myModule.js";
import myModule from "./myModule.js";

// 动态导入
const module = await import("./myModule.js");
```

#### 优缺点

- ✅ **优点**: 语言标准，静态分析，tree shaking，异步加载
- ❌ **缺点**: 需要现代浏览器或构建工具支持

## 详细对比分析

### 加载方式对比

| 模块系统   | 加载方式      | 适用环境           |
| ---------- | ------------- | ------------------ |
| IIFE       | 同步立即执行  | 浏览器/Node.js     |
| AMD        | 异步加载      | 浏览器             |
| CommonJS   | 同步加载      | Node.js            |
| UMD        | 自适应加载    | 浏览器/Node.js     |
| ES Modules | 静态/动态加载 | 现代浏览器/Node.js |

### 语法特性对比

| 特性         | IIFE     | AMD         | CommonJS       | UMD    | ES Modules    |
| ------------ | -------- | ----------- | -------------- | ------ | ------------- |
| 依赖声明     | 手动管理 | define 参数 | require 语句   | 自适应 | import 语句   |
| 导出方式     | 全局变量 | return 对象 | module.exports | 自适应 | export 关键字 |
| 静态分析     | 不支持   | 有限支持    | 有限支持       | 不支持 | 完全支持      |
| Tree Shaking | 不支持   | 不支持      | 不支持         | 不支持 | 完全支持      |
| 循环依赖     | 手动处理 | 支持        | 支持           | 支持   | 支持          |

### 性能对比

| 模块系统   | 加载性能       | 执行性能 | 缓存策略 |
| ---------- | -------------- | -------- | -------- |
| IIFE       | 快（立即执行） | 快       | 文件级别 |
| AMD        | 中等（异步）   | 中等     | 模块级别 |
| CommonJS   | 慢（同步）     | 快       | 模块级别 |
| UMD        | 中等           | 中等     | 文件级别 |
| ES Modules | 快（预解析）   | 快       | 模块级别 |

## 现代开发中的选择策略

### 1. 新项目推荐：ES Modules

对于现代前端项目，ES Modules 是首选方案：

```javascript
// package.json
{
  "type": "module",
  "exports": {
    ".": {
      "import": "./dist/esm/index.js",
      "require": "./dist/cjs/index.js"
    }
  }
}
```

**优势**:

- 语言标准，未来兼容性好
- 支持静态分析和 tree shaking
- 浏览器原生支持，无需额外工具
- 清晰的语法和结构

### 2. Node.js 项目：CommonJS + ESM 混合

对于 Node.js 项目，可以采用混合策略：

```javascript
// 支持ESM的Node.js项目
// package.json
{
  "type": "module",
  "main": "dist/cjs/index.js",
  "exports": {
    ".": {
      "import": "./dist/esm/index.js",
      "require": "./dist/cjs/index.js",
      "default": "./dist/esm/index.js"
    }
  }
}
```

### 3. 库开发：UMD + ESM 双模式

对于需要广泛兼容的库项目：

```javascript
// rollup.config.js
export default {
  input: "src/index.js",
  output: [
    {
      file: "dist/index.js",
      format: "umd",
      name: "MyLibrary",
    },
    {
      file: "dist/index.esm.js",
      format: "esm",
    },
  ],
};
```

## 构建工具配置示例

### Webpack 配置

```javascript
// webpack.config.js
module.exports = {
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    library: "MyLibrary",
    libraryTarget: "umd", // 支持umd、commonjs2、amd等
    globalObject: "this",
  },
  experiments: {
    outputModule: true, // 支持ESM输出
  },
};
```

### Rollup 配置

```javascript
// rollup.config.js
import { defineConfig } from "rollup";

export default defineConfig([
  {
    input: "src/index.js",
    output: {
      file: "dist/index.cjs.js",
      format: "cjs",
    },
  },
  {
    input: "src/index.js",
    output: {
      file: "dist/index.esm.js",
      format: "esm",
    },
  },
]);
```

## 迁移和兼容性策略

### 1. 从 CommonJS 迁移到 ESM

```javascript
// 旧版CommonJS
const fs = require("fs");
module.exports = { readFile: fs.readFile };

// 新版ESM
import { readFile } from "fs";
export { readFile };

// 兼容性包装
export default {
  readFile,
};
```

### 2. 动态导入的兼容处理

```javascript
// 动态导入兼容方案
async function loadModule(modulePath) {
  if (typeof import === 'function') {
    // ESM环境
    return await import(modulePath);
  } else {
    // CommonJS环境
    return require(modulePath);
  }
}
```

## 最佳实践总结

### 1. 项目类型选择

- **现代 Web 应用**: 优先选择 ES Modules
- **Node.js 库**: CommonJS + ESM 双模式
- **浏览器库**: UMD + ESM 双模式
- **遗留系统**: 保持原有模块系统

### 2. 构建策略

- 使用现代构建工具（Webpack 5+、Rollup、Vite）
- 配置多格式输出支持不同环境
- 利用 tree shaking 优化打包体积

### 3. 团队协作规范

- 统一模块导入导出风格
- 制定代码分割策略
- 建立依赖管理规范

## 未来展望

随着 JavaScript 语言的不断发展，ES Modules 正在成为事实标准。未来的趋势包括：

1. **更广泛的原生支持**: 更多环境和工具对 ESM 的原生支持
2. **更好的工具链**: 构建工具对 ESM 的优化和增强
3. **模块联邦**: 微前端架构下的模块共享方案
4. **WebAssembly 集成**: 与 WebAssembly 的模块互操作

## 结论

模块系统的选择应该基于项目需求、目标环境和团队技术栈。对于新项目，ES Modules 是最佳选择；对于需要广泛兼容的库项目，UMD + ESM 双模式是明智之举；而对于 Node.js 项目，CommonJS 仍然是可靠的选择。

理解不同模块系统的特性和适用场景，能够帮助我们在复杂的开发环境中做出正确的技术决策，构建出更高效、可维护的应用程序。
